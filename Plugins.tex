\section{Plug-ins: the Software Development Kit}
\label{sec:plugins}


Iris offers a full Software Development Kit that can be used to extend the Iris capabilities through the use of dynamically pluggable add-ons, or plug-ins.
The use cases for this are basically two:
\begin{description}
\item[New functionality] A developer may want to create SED-related capabilities in one or more Iris Components. This use case can be broken down in more detailed and concrete extensions, described later in this section.
\item[Custom-to-Standard adapters] A developer may want to create adapters that query a non-standard service, or load a non-standard data set, and then turn the data to SEDLib objects, thus effectively standardizing them so that they can be used by other components in the Iris environment, or saved and then reused by other VO-compliant applications. In other terms, one can achieve interoperability using the Iris infrastructure starting from a non-interoperable service, file, or tool. Iris actually has some built-in Custom-to-Standard adapters, like the sherpa-samp layer described in section \ref{sec:components}, or the ASDC plug-in interface that queries a quasi-standard service, described in section \ref{sec:asdc}.
\end{description}

\subsection{Anatomy of a Plug-in}
A single Jar file can archive several plug-ins, and each plug-in can bundle several Iris Components (see Section \ref{sec:architecture}).

Each Component can provide several additions to Iris, as described in some detail below:

\subsubsection{Menus and Buttons}
Usually, although not always, an Iris Component is visible to the user as either a set of buttons on the Iris Desktop, or as a set of menu items in the Iris menu bar, or both.

Menu items can be added to either the File menu or to the Tools menu, in a specific plugin-related folder.

While the implementation of such buttons and menu items could be built from scratch by implementing some Java Interfaces, a set of abstract classes implements a lot of the boiler plate code and makes some convenient assumptions about resource naming conventions. This way buttons and menu items can be created with very few lines of code, especially if one uses Maven [Introduce and reference Maven or remove this text], as Iris does.

Menu items and buttons can be customized by providing the button name, a description that will be rendered as a mouse-hover tooltip, and icons.

\subsubsection{Command Line}
Iris offers a framework for providing simple command line interfaces to its tools. For example, Iris ships a command line interface to the SED Builder (see Section \ref{sec:components}) that allows users to import non-standard files in bulk through scripts, possibly starting from templates saved interactively in the SED Builder.

This framework is extensible through a simple dispatching message. Each component has a name that is used to dispatch the command line argument to the right CLI engine. For instance, the line \verb|./Iris builder config.txt| instructs Iris to dispatch the \verb|config.txt| argument to the SED Builder's CLI engine.

Components bundled with plug-ins can provide such an engine by implementing the ICommandLineInterface Java Interface.

\subsubsection{SAMP Handlers}
A possible extension that plug-ins can offer to the users is SAMP Handlers: when Iris receives a SAMP message that matches the Handler's \verb|mtype|, the message is directly dispatched to the Handler itself by the Iris framework. As a matter of fact, Iris just offers a convenient shortcut to the excellent STIL implementation of SAMP, leveraging one of the best SAMP library available, and making it available to the users with just the bare minimum amount of work required. The setup of the SAMP infrastructure through STIL is all done by Iris.

A hook is provided for Components willing to send their own SAMP messages to the SAMP Hub, again as a convenient shortcut to STIL.

\subsubsection{Custom Events}
The Iris Events Framework is itself extensible: this way Plug-ins can, if needed, create their own nested loosely coupled architecture for their own Components.

\subsubsection{SED attachments}
Components can attach arbitrary objects to the SEDs managed by the SEDManager. This way they don't have to independently manage the additional information they might want to store about the individual SEDs. When SEDs are deleted, the manager takes care of releasing any references to the attachments, so to avoid memory leaks.



\subsection{Plug-in examples}
\subsubsection{ASDC - stable}
The Italian Space Agency Science Data Center (ASDC) hosts a database with tens of catalogs in a very wide range of wavelengths and providing time domain information.

A plug-in for providing Iris with a rich GUI to query their database was developed by the ASDC in a collaboration between the ASDC and the Iris teams. The plug-in became part of the main Iris release in v2.0 and provided a valuable test bench to review, validate, and improve the Iris Software Development Kit.

While the ASDC data query tool is now part of the Iris distribution, it still provides a very good example of how a plug-in can be integrated seamlessly in the Iris framework to add specific value to it. Integration can be so seamless, actually, that including the plug-in into the main Iris distribution is almost exclusively a matter of configuration than of coding.

The ASDC data query tool extends the capabilities of the SED Builder by providing a rich graphical user interface that allows users to check what archives to query, and since the ASDC query is a positional cone search, the client provides different adjustable search radii for each catalog which default to reasonable values consistent with the resolutive power of the individual instruments.

Moreover, the tool allows to query for specific observation time ranges, thus allowing basic time domain analysis of the SEDs.

This component proves several points about the Iris framework and SDK:
\begin{description}
\item[Custom-to-Standard adapters] The ASDC web service backing up the implementation of the query tool does not comply with any VO data access protocols (at least not yet), as it was designed as a private interface to their database to be consumed by a dedicated client. The client on the Iris desktop assumes that the service implements the private interface, and can query it. The data files coming from the service are actually compliant with the IVOA specifications, so they can be directly read by SEDLib and passed to the SEDManager.
\item[Agents loosely coupled interoperability] Although the ASDC plugin was not designed as part of Iris, it integrates seamlessly with the Iris built-in components. When the ASDC query tool instantiates an SED from the service, this gets listed in the SED Builder and visualized in the SED Viewer, even though it does not interact directly with any of them: they all interact only with the SED Manager and they get notified of changes by the events that this Controller fires when Views request operations on Models.
\item[The Iris SDK] As it will be explored in some detail in section \ref{sec:writeplugin}, a plug-in developer can pretty much focus on the implementation of her components' business logic, without worrying too much about how the boiler plate code required to the components themselves. By using the abstract classes that the Iris framework
provides, one can leverage the existing components with just a few lines of code and add value to entire application.
\end{description}

\subsubsection{Vizier - experimental}
Experimental plug-ins are shipped with Iris but they can only be activated by turning on switched on the Iris command line. For instance, if one starts Iris with the command \verb|./Iris --vizier| an experimental plugin for the CDS Vizier photometric service gets loaded in the usual Iris desktop.

While this component is, at the time of this writing, still experimental, it shows some properties of the Iris framework and SDK.

As for the ASDC plug-in, this component shows that one can use Iris and its framework to rapidly build an adapter from a custom service interface, and in this case also from a custom serialization, to make datasets interoperable with the other Iris tools, third party plug-ins, and possibly other VO tools.

\subsubsection{R - experimental}
An highly experimental proof-of-concept plug-in was developed to explore the possibility of interfacing Iris with rich analysis environments like R. The plug-in shows how one can \emph{beam} data from Iris to R and trigger some analysis on the dataset in R.


\subsection{Other Extensibility Points}

\subsubsection{Custom File Readers}
Iris supports a fair number of ﬁle formats natively: VOTable,
FITS, CSV, TSV, ASCII, and IPAC tables. However, new ﬁle ﬁlters can be created and
loaded at runtime. One can also create ﬁlters for the natively supported ﬁles: in this
case, the custom ﬁlter would parse the ﬁle and map the metadata to the IVOA Data
Model ﬁelds.

\subsubsection{Persistence}
Components can also get a handle to the configuration directory, usually a hidden folder in the user's home directory, if they need to persist information like user's preferences, local databases, or work sessions.